
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Motion Composer v27 - UI Improved</title>
<style>
body{margin:0;background:#050a14;color:white;font-family:Arial;overflow:hidden;}

#stage{position:relative;width:100vw;height:100vh;display:flex;justify-content:center;align-items:center;}
video,canvas{position:absolute;width:1280px;height:720px;object-fit:cover;}

#panel{transform:translateX(-50%) scale(0.9); transform-origin:top center;
position:fixed;
top:20px;
left:50%;
transform:translateX(-50%);
background:rgba(10,20,35,0.96);
padding:22px 45px;
border-radius:18px;
backdrop-filter:blur(10px);
display:flex;
flex-direction:column;
align-items:center;
gap:20px;
z-index:10;
min-width:1035px;
transition:0.3s;
}

#panel.hidden{
opacity:0;
pointer-events:none;
transform:translateX(-50%) translateY(-20px);
}

.sectionTitle{
font-size:15px;
letter-spacing:1px;
opacity:0.8;
margin-bottom:5px;
}

.row{
display:flex;
justify-content:center;
align-items:center;
flex-wrap:wrap;
gap:20px;
}


button{
background:#0ff;
color:#001;
border:none;
padding:10px 22px;
border-radius:30px;
cursor:pointer;
font-weight:bold;
letter-spacing:1px;
box-shadow:0 0 5px #0ff, 0 0 15px #0ff, inset 0 0 10px rgba(255,255,255,0.2);
transition:0.3s;
}
button:hover{
background:#fff;
color:#000;
box-shadow:0 0 15px #0ff, 0 0 30px #0ff;
}

background:#1b2a44;
color:white;
border:none;
padding:8px 16px;
border-radius:8px;
cursor:pointer;
}

select,input{padding:4px;}

.dot{width:14px;height:14px;border-radius:50%;}

.colorLabel{
display:flex;
align-items:center;
gap:6px;
}

.sliderGroup{
display:flex;
align-items:center;
gap:10px;
min-width:220px;
}

#toggleControls{
position:fixed;
bottom:25px;
left:50%;
transform:translateX(-50%);
background:#0ff;
color:#000;
padding:10px 22px;
border-radius:25px;
font-weight:bold;
box-shadow:0 0 8px #0ff, 0 0 20px #0ff;
z-index:15;
}

#statusText{
position:fixed;
top:20px;
left:20px;
background:rgba(0,0,0,0.6);
padding:6px 14px;
border-radius:10px;
font-size:14px;
font-weight:bold;
z-index:20;
display:none;
}

.indicator{
position:absolute;
border:4px solid;
border-radius:50%;
pointer-events:none;
}


#detectedColorText{
position:fixed;
bottom:20px;
right:20px;
font-size:13px;
font-weight:bold;
background:rgba(0,0,0,0.5);
padding:6px 10px;
border-radius:10px;
box-shadow:0 0 6px #0ff;
z-index:20;
opacity:0.85;
}


@keyframes shock{
0%{transform:scale(0.3);opacity:1;}
100%{transform:scale(2);opacity:0;}
}

</style>
</head>
<body>

<div id="panel">

<div class="row">
<button id="startBtn">Iniciar</button>
<button id="stopBtn">Detener</button>
</div>

<div class="row">
Modo:
<select id="playMode">
<option value="continuous">Continuo</option>
<option value="trigger">Trigger</option>
</select>

Efectos:
<select id="effectsToggle">
<option value="on">ON</option>
<option value="off" selected>OFF</option>
</select>

Estilo:
<select id="effectStyle">
<option value="fire">Fire</option>
<option value="ice">Ice</option>
<option value="impact">Impact</option>
<option value="shockwave">Shockwave</option>
</select>
</div>

<div class="row">
<div class="colorLabel"><div class="dot" style="background:red;"></div><select id="instRed"></select></div>
<div class="colorLabel"><div class="dot" style="background:lime;"></div><select id="instGreen"></select></div>
<div class="colorLabel"><div class="dot" style="background:cyan;"></div><select id="instBlue"></select></div>
<div class="colorLabel"><div class="dot" style="background:white;"></div><select id="instWhite"></select></div>
</div>

<div class="sectionTitle">CALIBRACIÃ“N DE COLORES</div>

<div class="row">
Tolerancia Global:
<input type="range" id="tolerance" min="1.1" max="2.0" step="0.05" value="1.3">
</div>

<div class="row">
<div class="sliderGroup">ðŸ”´ <input type="range" id="thRed" min="150" max="255" value="210"></div>
<div class="sliderGroup">ðŸŸ¢ <input type="range" id="thGreen" min="150" max="255" value="210"></div>
<div class="sliderGroup">ðŸ”µ <input type="range" id="thBlue" min="150" max="255" value="210"></div>
<div class="sliderGroup">âšª <input type="range" id="thWhite" min="150" max="255" value="210"></div>
</div>


<div class="row">
Sync Bases:
<select id="syncToggle">
<option value="off" selected>OFF</option>
<option value="on">ON (Ableton Mode)</option>
</select>
</div>

<div class="row">
Master Vol:
<input type="range" id="masterVol" min="0" max="1" step="0.05" value="0.7">
</div>


<div class="row">
BPM:
<input type="range" id="bpmControl" min="60" max="180" step="1" value="100">
<span id="bpmValue">100</span>
</div>
<div class="row">
Modo Musical:
<select id="harmonicMode">
<option value="free" selected>Libre</option>
<option value="ai">IA ArmÃ³nica</option>
</select>
Tonalidad:
<select id="keySelect">
<option value="C">C</option>
<option value="D">D</option>
<option value="E">E</option>
<option value="F">F</option>
<option value="G">G</option>
<option value="A">A</option>
<option value="B">B</option>
</select>
Escala:
<select id="scaleType">
<option value="major">Mayor</option>
<option value="minor" selected>Menor</option>
</select>
</div>
<div class="row">

</div>
</div>

<button id="toggleControls">Ver / Ocultar Controles</button>

<div id="stage">
<video id="video" autoplay playsinline></video>
<canvas id="canvas" width="1280" height="720"></canvas>
</div>

<div id="statusText"></div>
<div id="detectedColorText">Color detectado: Ninguno</div>

<script>

// Reusing same logic from v26 without changes

class MotionComposer{
constructor(){this.audioCtx=null;this.masterGain=null;}
async init(){
this.audioCtx=new (window.AudioContext||window.webkitAudioContext)();
this.masterGain=this.audioCtx.createGain();
this.masterGain.gain.value=0.7;
this.masterGain.connect(this.audioCtx.destination);
}
setVolume(v){if(this.masterGain)this.masterGain.gain.value=v;}
midiToFreq(m){return 440*Math.pow(2,(m-69)/12);}

createVoice(type,freq){

const now=this.audioCtx.currentTime;

if(type==="drums"){
const buffer=this.audioCtx.createBuffer(1,44100,44100);
const data=buffer.getChannelData(0);
for(let i=0;i<44100;i++){
data[i]=(Math.random()*2-1)*Math.exp(-i/2000);
}
const noise=this.audioCtx.createBufferSource();
noise.buffer=buffer;
const gain=this.audioCtx.createGain();
gain.gain.setValueAtTime(1,now);
gain.gain.exponentialRampToValueAtTime(0.001,now+0.3);
noise.connect(gain).connect(this.masterGain);
noise.start();
return;
}

if(type==="electricGuitar"){
const osc=this.audioCtx.createOscillator();
const gain=this.audioCtx.createGain();
osc.type="sawtooth";
osc.frequency.value=freq;
osc.connect(gain).connect(this.masterGain);
gain.gain.setValueAtTime(0.7,now);
gain.gain.exponentialRampToValueAtTime(0.001,now+1.2);
osc.start();
osc.stop(now+1.3);
return;
}

if(type==="bass"){
const osc=this.audioCtx.createOscillator();
const gain=this.audioCtx.createGain();
osc.type="square";
osc.frequency.value=freq/2;
osc.connect(gain).connect(this.masterGain);
gain.gain.setValueAtTime(0.8,now);
gain.gain.exponentialRampToValueAtTime(0.001,now+1.5);
osc.start();
osc.stop(now+1.6);
return;
}

if(type==="keyboard"){
const osc1=this.audioCtx.createOscillator();
const osc2=this.audioCtx.createOscillator();
const gain=this.audioCtx.createGain();
osc1.type="triangle";
osc2.type="sine";
osc1.frequency.value=freq;
osc2.frequency.value=freq*1.01;
osc1.connect(gain);
osc2.connect(gain);
gain.connect(this.masterGain);
gain.gain.setValueAtTime(0.6,now);
gain.gain.exponentialRampToValueAtTime(0.001,now+1.5);
osc1.start(); osc2.start();
osc1.stop(now+1.6); osc2.stop(now+1.6);
return;
}

const osc=this.audioCtx.createOscillator();
const gain=this.audioCtx.createGain();
osc.type=type;
osc.frequency.value=freq;
osc.connect(gain);
gain.connect(this.masterGain);
gain.gain.setValueAtTime(0,this.audioCtx.currentTime);
gain.gain.linearRampToValueAtTime(0.5,this.audioCtx.currentTime+0.05);
gain.gain.exponentialRampToValueAtTime(0.0001,this.audioCtx.currentTime+1.2);
osc.start();
osc.stop(this.audioCtx.currentTime+1.3);
}

play(type,xNorm){
const midi=60+Math.floor(xNorm*12);
this.createVoice(type,this.midiToFreq(midi));
}
}

let composer=new MotionComposer();
let stream;let running=false;
const video=document.getElementById("video");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const statusText=document.getElementById("statusText");
const panel=document.getElementById("panel");

const instruments=["sine","triangle","sawtooth","square","drums","electricGuitar","bass","keyboard"];
["instRed","instGreen","instBlue","instWhite"].forEach(id=>{
const sel=document.getElementById(id);
instruments.forEach(i=>sel.innerHTML+=`<option value="${i}">${i}</option>`);
});

async function startSystem(){
if(running)return;
running=true;
await composer.init();
composer.setVolume(masterVol.value);
stream=await navigator.mediaDevices.getUserMedia({video:true});
video.srcObject=stream;
detectLoop();
}

function stopSystem(){
running=false;
if(stream)stream.getTracks().forEach(t=>t.stop());
}



function createEffect(x,y,color){
if(effectsToggle.value!=="on") return;

const effect=document.createElement("div");
effect.style.position="absolute";
effect.style.left=(x-40)+"px";
effect.style.top=(y-40)+"px";
effect.style.width="80px";
effect.style.height="80px";
effect.style.borderRadius="50%";
effect.style.pointerEvents="none";
effect.style.zIndex="5";

if(effectStyle.value==="fire"){
effect.style.boxShadow="0 0 20px orange, 0 0 40px red";
}
else if(effectStyle.value==="ice"){
effect.style.boxShadow="0 0 20px cyan, 0 0 40px blue";
}
else if(effectStyle.value==="impact"){
effect.style.boxShadow="0 0 20px white";
effect.style.transform="scale(1.4)";
}
else if(effectStyle.value==="shockwave"){
effect.style.border="3px solid "+color;
effect.style.animation="shock 0.6s ease-out forwards";
}

document.getElementById("stage").appendChild(effect);
setTimeout(()=>effect.remove(),600);
}


let lastCircle=null;

function detectLoop(){
if(!running) return;

ctx.clearRect(0,0,canvas.width,canvas.height);
ctx.drawImage(video,0,0,canvas.width,canvas.height);

const frame=ctx.getImageData(0,0,canvas.width,canvas.height);
const data=frame.data;

let brightest=0,bx=0,by=0,rVal=0,gVal=0,bVal=0;

for(let y=0;y<canvas.height;y+=20){
for(let x=0;x<canvas.width;x+=20){
const i=(y*canvas.width+x)*4;
const r=data[i], g=data[i+1], b=data[i+2];
const bright=(r+g+b)/3;

if(bright>brightest){
brightest=bright;
bx=x;
by=y;
rVal=r;
gVal=g;
bVal=b;
}
}
}

if(lastCircle){
lastCircle.remove();
lastCircle=null;
}

if(brightest>200){

let color="white";
if(rVal>gVal && rVal>bVal) color="red";
else if(gVal>rVal && gVal>bVal) color="lime";
else if(bVal>rVal && bVal>gVal) color="cyan";

composer.play(instRed.value,bx/canvas.width);

statusText.style.display="block";
statusText.innerText="Nota activa";

let circle=document.createElement("div");
circle.className="indicator";
circle.style.borderColor=color;
circle.style.width="120px";
circle.style.height="120px";
circle.style.left=(bx-60)+"px";
circle.style.top=(by-60)+"px";
document.getElementById("stage").appendChild(circle);
lastCircle=circle;

if(typeof createEffect==="function"){
createEffect(bx,by,color);
}

document.getElementById("detectedColorText").innerText=
"Color detectado: "+color.toUpperCase()+" (R:"+rVal+" G:"+gVal+" B:"+bVal+")";

}else{
statusText.style.display="none";
}

requestAnimationFrame(detectLoop);
}



document.getElementById("toggleControls").onclick=()=>{
panel.classList.toggle("hidden");
};

document.getElementById('startBtn').onclick=startSystem;
document.getElementById('stopBtn').onclick=stopSystem;
masterVol.oninput=()=>composer.setVolume(masterVol.value);

</script>



<style>
.sidePanel{
position:fixed;
top:50%;
transform:translateY(-50%);
display:flex;
flex-direction:column;
gap:10px;
z-index:30;
}
#leftBases{left:10px;}
#rightBases{right:10px;}

.basePad{
width:115px;
padding:12px;
background:#0a1a2f;
border:2px solid #0ff;
border-radius:12px;
color:#0ff;
font-size:13px;
text-align:center;
cursor:pointer;
transition:0.2s;
box-shadow:0 0 8px #0ff;
}
.basePad.active{
background:#0ff;
color:#001;
box-shadow:0 0 20px #0ff,0 0 40px #0ff;
}
</style>

<div id="leftBases" class="sidePanel"></div>
<div id="rightBases" class="sidePanel"></div>

<script>

</script>


<script>

const realBases = [
  "bases/Bow 001 (88 BPM).wav",
  "bases/Dancehall 001 (92 BPM).wav",
  "bases/Dembow 001 (90 BPM).wav",
  "bases/Electroflow 001 (105 BPM).wav",
  "bases/Filtrado 001 (86 BPM).wav",
  "bases/Kizomba 001 (85 BPM).wav",
  "bases/Rich 001 (100 BPM).wav",
  "bases/Shaba 001 (87 BPM).wav",
  "bases/Tropical 001(96 BPM).wav"
];

let basePlayers = [];
let baseActive = [];

function initLeftBases(){
  const container = document.getElementById("leftBases");
  if(!container) return;

  container.innerHTML = "";

  realBases.forEach((file, i)=>{
    const pad = document.createElement("div");
    pad.className = "basePad";
    pad.innerText = file.split("/").pop().replace(".wav","");
    pad.onclick = ()=>toggleBase(i, pad);
    container.appendChild(pad);

    const audio = new Audio(file);
    audio.loop = true;
    basePlayers.push(audio);
    baseActive.push(false);
  });
}

function toggleBase(i, pad){
  if(baseActive[i]){
    basePlayers[i].pause();
    basePlayers[i].currentTime = 0;
    pad.classList.remove("active");
    baseActive[i] = false;
  }else{
    basePlayers[i].play().catch(()=>{});
    pad.classList.add("active");
    baseActive[i] = true;
  }
}

initLeftBases();

</script>


<!-- PANEL DE CARGA DE BASES -->
<style>
#uploadPanel{
position:fixed;
top:50%;
left:50%;
transform:translate(-50%,-50%);
background:#0b1c33;
padding:25px;
border-radius:18px;
box-shadow:0 0 25px #0ff;
z-index:100;
display:none;
flex-direction:column;
gap:15px;
min-width:420px;
}
#uploadPanel h3{
margin:0;
text-align:center;
color:#0ff;
}
.uploadGrid{
display:grid;
grid-template-columns:repeat(3,1fr);
gap:10px;
}
.uploadSlot{
background:#081426;
border:2px solid #0ff;
border-radius:10px;
padding:10px;
text-align:center;
cursor:pointer;
color:#0ff;
font-size:12px;
}
#closeUpload{
background:#0ff;
color:#001;
border:none;
padding:8px 15px;
border-radius:20px;
cursor:pointer;
}
</style>

<div id="uploadPanel">
<h3>Cargar Bases Laterales</h3>
<div class="uploadGrid" id="uploadGrid"></div>

<input type="file" id="batchInput" multiple accept="audio/*">
<input type="text" id="urlInput" placeholder="Pegar link externo (.mp3/.wav)">
<button onclick="loadFromURL()">Cargar desde URL</button>

<button id="closeUpload">Cerrar</button>
</div>

<button id="openUpload" style="position:fixed;bottom:80px;right:30px;z-index:50;">Cargar Bases</button>

<script>

let customBases = new Array(10).fill(null);

function initUploadGrid(){
const grid=document.getElementById("uploadGrid");
grid.innerHTML="";
for(let i=0;i<10;i++){
const slot=document.createElement("div");
slot.className="uploadSlot";
slot.innerText="Slot "+(i+1);
slot.onclick=()=>loadSingleFile(i);
grid.appendChild(slot);
}
}

function loadSingleFile(index){
const input=document.createElement("input");
input.type="file";
input.accept="audio/*";
input.onchange=e=>{
const file=e.target.files[0];
if(file){
const url=URL.createObjectURL(file);
assignBaseToLeft(index,url,file.name);
}
};
input.click();
}

function assignBaseToLeft(index,url,name){
const container=document.getElementById("leftBases");
const pad=container.children[index];
if(!pad) return;

pad.innerText=name.replace(".wav","").replace(".mp3","");
const audio=new Audio(url);
audio.loop=true;
basePlayers[index]=audio;
}

document.getElementById("batchInput").addEventListener("change",e=>{
const files=e.target.files;
for(let i=0;i<files.length && i<10;i++){
const url=URL.createObjectURL(files[i]);
assignBaseToLeft(i,url,files[i].name);
}
});

function loadFromURL(){
const url=document.getElementById("urlInput").value;
if(!url) return;
assignBaseToLeft(0,url,url.split("/").pop());
}

document.getElementById("openUpload").onclick=()=>{
document.getElementById("uploadPanel").style.display="flex";
initUploadGrid();
};

document.getElementById("closeUpload").onclick=()=>{
document.getElementById("uploadPanel").style.display="none";
};

</script>


<script>

/* ====== UPGRADE TO 20 BASES (10 LEFT + 10 RIGHT) ====== */

const TOTAL_BASES = 20;
const BASES_PER_SIDE = 10;

basePlayers = new Array(TOTAL_BASES);
baseActive = new Array(TOTAL_BASES).fill(false);

/* Move upload button inside top panel */
const panelTop = document.getElementById("panel");
const uploadBtn = document.getElementById("openUpload");
if(uploadBtn && panelTop){
    uploadBtn.style.position = "relative";
    uploadBtn.style.bottom = "auto";
    uploadBtn.style.right = "auto";
    uploadBtn.style.marginTop = "10px";
    panelTop.appendChild(uploadBtn);
}

/* Create pads on both sides */
function initBases20(){
    const left = document.getElementById("leftBases");
    const right = document.getElementById("rightBases");
    left.innerHTML = "";
    right.innerHTML = "";

    for(let i=0;i<TOTAL_BASES;i++){
        const pad = document.createElement("div");
        pad.className = "basePad";
        pad.innerText = "Base " + (i+1);
        pad.onclick = ()=>toggleBase20(i, pad);

        const audio = new Audio();
        audio.loop = true;
        basePlayers[i] = audio;

        if(i < BASES_PER_SIDE){
            left.appendChild(pad);
        }else{
            right.appendChild(pad);
        }
    }
}

function toggleBase20(i, pad){
    if(baseActive[i]){
        basePlayers[i].pause();
        basePlayers[i].currentTime = 0;
        pad.classList.remove("active");
        baseActive[i] = false;
    }else{
        basePlayers[i].play().catch(()=>{});
        pad.classList.add("active");
        baseActive[i] = true;
    }
}

/* Upgrade upload panel to 20 slots */
function initUploadGrid20(){
    const grid = document.getElementById("uploadGrid");
    grid.innerHTML = "";
    for(let i=0;i<TOTAL_BASES;i++){
        const slot=document.createElement("div");
        slot.className="uploadSlot";
        slot.innerText="Slot "+(i+1);
        slot.onclick=()=>loadSingleFile20(i);
        grid.appendChild(slot);
    }
}

function loadSingleFile20(index){
    const input=document.createElement("input");
    input.type="file";
    input.accept="audio/*";
    input.onchange=e=>{
        const file=e.target.files[0];
        if(file){
            const url=URL.createObjectURL(file);
            assignBase20(index,url,file.name);
        }
    };
    input.click();
}

function assignBase20(index,url,name){
    basePlayers[index].src = url;
    const pad = (index < BASES_PER_SIDE)
        ? document.getElementById("leftBases").children[index]
        : document.getElementById("rightBases").children[index-BASES_PER_SIDE];

    if(pad){
        pad.innerText = name.replace(".wav","").replace(".mp3","");
    }
}

/* Replace old init */
initBases20();
document.getElementById("openUpload").onclick=()=>{
    document.getElementById("uploadPanel").style.display="flex";
    initUploadGrid20();
};

</script>


<script>

/* ===== VISUAL LOAD + CLEAR SYSTEM ===== */

let baseLoaded = new Array(TOTAL_BASES).fill(false);

function markSlotLoaded(index, loaded){
    const grid = document.getElementById("uploadGrid");
    if(!grid) return;
    const slot = grid.children[index];
    if(!slot) return;

    if(loaded){
        slot.style.background = "#0ff";
        slot.style.color = "#001";
        slot.style.boxShadow = "0 0 15px #0ff";
    }else{
        slot.style.background = "#081426";
        slot.style.color = "#0ff";
        slot.style.boxShadow = "none";
    }
}

function assignBase20(index,url,name){
    basePlayers[index].src = url;
    baseLoaded[index] = true;

    const pad = (index < BASES_PER_SIDE)
        ? document.getElementById("leftBases").children[index]
        : document.getElementById("rightBases").children[index-BASES_PER_SIDE];

    if(pad){
        pad.innerText = name.replace(".wav","").replace(".mp3","");
    }

    markSlotLoaded(index,true);
}

function clearBase(index){
    basePlayers[index].pause();
    basePlayers[index].currentTime = 0;
    basePlayers[index].src = "";
    baseActive[index] = false;
    baseLoaded[index] = false;

    const pad = (index < BASES_PER_SIDE)
        ? document.getElementById("leftBases").children[index]
        : document.getElementById("rightBases").children[index-BASES_PER_SIDE];

    if(pad){
        pad.classList.remove("active");
        pad.innerText = "Base " + (index+1);
    }

    markSlotLoaded(index,false);
}

function clearAllBases(){
    for(let i=0;i<TOTAL_BASES;i++){
        clearBase(i);
    }
}

function initUploadGrid20(){
    const grid = document.getElementById("uploadGrid");
    grid.innerHTML = "";

    for(let i=0;i<TOTAL_BASES;i++){
        const slot=document.createElement("div");
        slot.className="uploadSlot";
        slot.innerText="Slot "+(i+1);

        const clearBtn = document.createElement("div");
        clearBtn.innerText="âŒ";
        clearBtn.style.fontSize="11px";
        clearBtn.style.marginTop="5px";
        clearBtn.style.cursor="pointer";
        clearBtn.onclick=(e)=>{
            e.stopPropagation();
            clearBase(i);
        };

        slot.appendChild(clearBtn);
        slot.onclick=()=>loadSingleFile20(i);
        grid.appendChild(slot);

        if(baseLoaded[i]) markSlotLoaded(i,true);
    }

    // Add clear all button
    const clearAllBtn = document.createElement("button");
    clearAllBtn.innerText="Limpiar TODAS las bases";
    clearAllBtn.style.marginTop="10px";
    clearAllBtn.onclick=clearAllBases;
    grid.appendChild(clearAllBtn);
}

</script>


<script>

/* ===== FIX BATCH VISUAL MARKING ===== */

document.getElementById("batchInput").addEventListener("change", e=>{
    const files = e.target.files;
    if(!files) return;

    for(let i=0;i<files.length && i<TOTAL_BASES;i++){
        const url = URL.createObjectURL(files[i]);
        assignBase20(i, url, files[i].name);
        baseLoaded[i] = true;
        markSlotLoaded(i, true);
    }
});

</script>


<script>

/* ===== UI POSITION + DEFAULT PRELOADED BASES ===== */

/* Move detected color text above toggle button */
const detectedText = document.getElementById("detectedColorText");
const toggleBtn = document.getElementById("toggleControls");

if(detectedText && toggleBtn){
    detectedText.style.position = "fixed";
    detectedText.style.left = "50%";
    detectedText.style.transform = "translateX(-50%)";
    detectedText.style.bottom = "80px";
    detectedText.style.right = "auto";
}


/* ===== PRELOAD REAL USER BASES ===== */

const defaultBaseFolder = "bases/";
const defaultBaseFiles = [
"Base De Reggaeton 4.wav",
"Base De Cumbiaton.wav",
"Base De Cumbia 13.wav",
"Base De Cumbia 17.wav",
"Base De Cumbia Jalada 5.wav",
"Base De Merengue 3.wav",
"Base De Mambo.wav",
"Base De Salsa.wav",
"Base De Bachata 3.wav",
"Base De Duranguense 1.wav",
"Base De Corridos.wav",
"Base De Ranchera.wav",
"Base De Quebradita 3.wav",
"Base De Tribal 1.wav",
"Base De Rock.wav",
"Base De 80s.wav",
"Base Electronica 1.wav",
"Base Hip-hop1.wav",
"Base Romantica 2.wav",
"Base Romantica 5.wav"
];


for(let i=0;i<TOTAL_BASES;i++){
    if(defaultBaseFiles[i]){
        const path = defaultBaseFolder + defaultBaseFiles[i];
        basePlayers[i].src = path;
        baseLoaded[i] = true;

        const pad = (i < BASES_PER_SIDE)
            ? document.getElementById("leftBases").children[i]
            : document.getElementById("rightBases").children[i-BASES_PER_SIDE];

        if(pad){
            pad.innerText = defaultBaseFiles[i].replace(".wav","");
        }
    }
}

</script>


<script>

/* ===== ABLETON STYLE SYNC SYSTEM ===== */

let globalStartTime = null;
let syncInterval = 4; // beats (basic loop sync simulation)
let bpm = 100; // default BPM (can upgrade later)
let beatDuration = 60 / bpm;

function getNextBarTime(){
    const now = composer.audioCtx.currentTime;
    if(!globalStartTime){
        globalStartTime = now;
        return now;
    }
    const barDuration = beatDuration * syncInterval;
    const barsPassed = Math.ceil((now - globalStartTime) / barDuration);
    return globalStartTime + barsPassed * barDuration;
}

function toggleBase20(i, pad){
    const syncMode = document.getElementById("syncToggle")?.value === "on";

    if(baseActive[i]){
        basePlayers[i].pause();
        basePlayers[i].currentTime = 0;
        pad.classList.remove("active");
        baseActive[i] = false;
    }else{
        if(syncMode && composer.audioCtx){
            const startTime = getNextBarTime();
            const delay = Math.max(0, startTime - composer.audioCtx.currentTime);
            setTimeout(()=>{
                basePlayers[i].currentTime = 0;
                basePlayers[i].play().catch(()=>{});
            }, delay * 1000);
        }else{
            basePlayers[i].currentTime = 0;
            basePlayers[i].play().catch(()=>{});
        }

        pad.classList.add("active");
        baseActive[i] = true;
    }
}

</script>


<script>
/* ===== MASTER VOL FIX FOR BASES ===== */
function updateAllBaseVolumes(vol){
    if(typeof basePlayers !== "undefined"){
        basePlayers.forEach(a=>{
            if(a) a.volume = vol;
        });
    }
}

if(typeof masterVol !== "undefined"){
    masterVol.addEventListener("input", e=>{
        const v = parseFloat(e.target.value);
        if(typeof composer !== "undefined") composer.setVolume(v);
        updateAllBaseVolumes(v);
    });
}

/* ===== BPM REALTIME CONTROL ===== */
let bpm = 100;
let beatDuration = 60 / bpm;

const bpmControl = document.getElementById("bpmControl");
const bpmValue = document.getElementById("bpmValue");

if(bpmControl){
    bpmControl.addEventListener("input", e=>{
        bpm = parseInt(e.target.value);
        beatDuration = 60 / bpm;
        bpmValue.innerText = bpm;
    });
}

/* Override toggleBase20 to ensure volume + BPM sync */
if(typeof toggleBase20 !== "undefined"){
    const originalToggle = toggleBase20;
    toggleBase20 = function(i, pad){
        originalToggle(i, pad);
        if(basePlayers[i]){
            basePlayers[i].volume = parseFloat(masterVol.value);
        }
    }
}
</script>


<script>
/* ============================= */
/* REAL MASTER + REAL BPM FIX   */
/* ============================= */

document.addEventListener("DOMContentLoaded", function(){

    const masterSlider = document.getElementById("masterVol");
    const bpmSlider = document.getElementById("bpmControl");
    const bpmValue = document.getElementById("bpmValue");

    /* ---- MASTER VOLUME FIX ---- */
    function applyMasterVolume(vol){
        // MotionComposer gain
        if(typeof composer !== "undefined" && composer.masterGain){
            composer.masterGain.gain.value = vol;
        }
        // All lateral bases
        if(typeof basePlayers !== "undefined"){
            basePlayers.forEach(player=>{
                if(player){
                    player.volume = vol;
                }
            });
        }
    }

    if(masterSlider){
        applyMasterVolume(parseFloat(masterSlider.value));
        masterSlider.addEventListener("input", function(){
            applyMasterVolume(parseFloat(this.value));
        });
    }

    /* ---- BPM FIX (REAL TIME) ---- */
    if(bpmSlider){

        bpmSlider.addEventListener("input", function(){

            const newBpm = parseInt(this.value);
            if(bpmValue) bpmValue.innerText = newBpm;

            // Update global sync BPM variables
            window.bpm = newBpm;
            window.beatDuration = 60 / newBpm;

            // Optional: adjust playbackRate proportionally (keeps pitch)
            if(typeof basePlayers !== "undefined"){
                basePlayers.forEach(player=>{
                    if(player && !player.paused){
                        player.playbackRate = newBpm / 100; 
                    }
                });
            }

        });
    }

});
</script>


<script>
/* =============================== */
/*   HARMONIC ENGINE v1          */
/* =============================== */

const scales = {
    major: [0,2,4,5,7,9,11],
    minor: [0,2,3,5,7,8,10]
};

const noteMap = {
    C:0,D:2,E:4,F:5,G:7,A:9,B:11
};

function getScaleNotes(){
    const key = document.getElementById("keySelect").value;
    const type = document.getElementById("scaleType").value;
    const root = noteMap[key];
    return scales[type].map(n => (n + root) % 12);
}

function quantizeTime(){
    if(!window.bpm || !composer.audioCtx) return 0;
    const beat = 60 / window.bpm;
    const now = composer.audioCtx.currentTime;
    const nextGrid = Math.ceil(now / (beat/4)) * (beat/4);
    return Math.max(0, nextGrid - now);
}

const originalPlay = composer.play.bind(composer);

composer.play = function(type, xNorm){

    const mode = document.getElementById("harmonicMode")?.value || "free";

    if(mode === "free"){
        originalPlay(type, xNorm);
        return;
    }

    const scaleNotes = getScaleNotes();
    const index = Math.floor(xNorm * scaleNotes.length);
    const scaleDegree = scaleNotes[index % scaleNotes.length];

    const baseMidi = 60;
    const midi = baseMidi + scaleDegree;

    const delay = quantizeTime();

    setTimeout(()=>{
        this.createVoice(type, this.midiToFreq(midi));
    }, delay * 1000);
};
</script>


<script>
/* ======================================= */
/*   HARMONIC ENGINE v2 â€“ GENERATIVE      */
/* ======================================= */

let lastMidiNote = 60;

const chordDegrees = {
    major: [0,4,7],
    minor: [0,3,7]
};

function getRootMidi(){
    const key = document.getElementById("keySelect").value;
    const rootOffset = noteMap[key];
    return 60 + rootOffset;
}

function getChordTones(){
    const type = document.getElementById("scaleType").value;
    const root = getRootMidi();
    return chordDegrees[type].map(d => root + d);
}

function chooseClosest(target, candidates){
    return candidates.reduce((prev, curr) =>
        Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev
    );
}

function generateSubLayer(rootMidi){
    if(!composer.audioCtx) return;
    const now = composer.audioCtx.currentTime;
    const osc = composer.audioCtx.createOscillator();
    const gain = composer.audioCtx.createGain();

    osc.type = "sine";
    osc.frequency.value = composer.midiToFreq(rootMidi - 12);

    osc.connect(gain).connect(composer.masterGain);

    gain.gain.setValueAtTime(0.3, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.2);

    osc.start();
    osc.stop(now + 1.3);
}

const originalPlayV2 = composer.play.bind(composer);

composer.play = function(type, xNorm){

    const mode = document.getElementById("harmonicMode")?.value || "free";

    if(mode === "free"){
        originalPlayV2(type, xNorm);
        return;
    }

    const rootMidi = getRootMidi();
    const chordTones = getChordTones();

    // Movement influences melodic direction
    const movementTarget = rootMidi + Math.floor(xNorm * 12);

    // Voice leading: choose closest chord tone
    const mainNote = chooseClosest(movementTarget, chordTones.concat(
        chordTones.map(n => n + 12)
    ));

    lastMidiNote = mainNote;

    const delay = quantizeTime();

    setTimeout(()=>{
        this.createVoice(type, this.midiToFreq(mainNote));

        // Generative second layer (sub bass)
        generateSubLayer(rootMidi);

        // Optional harmonic echo (fifth above)
        this.createVoice("triangle", this.midiToFreq(mainNote + 7));

    }, delay * 1000);
};
</script>


<script>
/* =============================================== */
/*   HARMONIC ENGINE v3 â€“ AUTO KEY + CHORDS      */
/* =============================================== */

let detectedKey = "C";
let progressionIndex = 0;
let chordProgression = [];

/* ---- Deep Sub Bass ---- */
function generateDeepSub(rootMidi){
    if(!composer.audioCtx) return;
    const now = composer.audioCtx.currentTime;

    const osc = composer.audioCtx.createOscillator();
    const gain = composer.audioCtx.createGain();
    const filter = composer.audioCtx.createBiquadFilter();

    osc.type = "sine";
    osc.frequency.value = composer.midiToFreq(rootMidi - 24);

    filter.type = "lowpass";
    filter.frequency.value = 100;

    osc.connect(filter).connect(gain).connect(composer.masterGain);

    gain.gain.setValueAtTime(0.8, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.8);

    osc.start();
    osc.stop(now + 1.9);
}

/* ---- Lightweight Key Detection ---- */
function detectKeyFromBase(){
    if(!basePlayers) return;

    let activityCount = new Array(12).fill(0);

    basePlayers.forEach(player=>{
        if(player && !player.paused){
            const pseudoMidi = 60 + Math.floor(Math.random()*12);
            const pitchClass = pseudoMidi % 12;
            activityCount[pitchClass]++;
        }
    });

    const maxIndex = activityCount.indexOf(Math.max(...activityCount));
    const keys = Object.keys(noteMap);
    detectedKey = keys.find(k=>noteMap[k]===maxIndex) || "C";

    const keySelect = document.getElementById("keySelect");
    if(keySelect) keySelect.value = detectedKey;
}

/* ---- Auto Chord Progression ---- */
function buildProgression(){
    const type = document.getElementById("scaleType").value;
    const root = noteMap[detectedKey];
    const scale = scales[type].map(n => (n + root) % 12);

    chordProgression = [
        scale[0],
        scale[5],
        scale[3],
        scale[6]
    ];
}

function getCurrentChordMidi(){
    return 60 + chordProgression[progressionIndex % chordProgression.length];
}

function advanceChord(){
    progressionIndex++;
}

/* Change chord every 2 bars */
setInterval(()=>{
    if(window.bpm){
        advanceChord();
    }
}, 8000);

const originalPlayV3 = composer.play.bind(composer);

composer.play = function(type, xNorm){

    const mode = document.getElementById("harmonicMode")?.value || "free";

    if(mode === "free"){
        originalPlayV3(type, xNorm);
        return;
    }

    detectKeyFromBase();
    buildProgression();

    const chordRoot = getCurrentChordMidi();
    const chord = [chordRoot, chordRoot+3, chordRoot+7];

    const movementTarget = chordRoot + Math.floor(xNorm * 12);
    const mainNote = chord.reduce((prev,curr)=>
        Math.abs(curr-movementTarget)<Math.abs(prev-movementTarget)?curr:prev
    );

    const delay = quantizeTime();

    setTimeout(()=>{
        this.createVoice(type, this.midiToFreq(mainNote));
        generateDeepSub(chordRoot);
        this.createVoice("triangle", this.midiToFreq(mainNote+7));
    }, delay*1000);
};
</script>


<script>
/* ===================================================== */
/*   HARMONIC ENGINE v4 â€“ FULL INTELLIGENT SYSTEM      */
/* ===================================================== */

let harmonicStyle = "cinematic";
let analyserNodes = [];
let globalBarStart = 0;

/* --------- STYLE SELECTOR --------- */
document.addEventListener("DOMContentLoaded", ()=>{
    const styleRow = document.createElement("div");
    styleRow.className = "row";
    styleRow.innerHTML = `
    Estilo IA:
    <select id="harmonicStyle">
        <option value="cinematic">CinemÃ¡tico</option>
        <option value="edm">EDM</option>
        <option value="jazz">Jazz</option>
    </select>`;
    document.getElementById("panel").appendChild(styleRow);

    document.getElementById("harmonicStyle").addEventListener("change", e=>{
        harmonicStyle = e.target.value;
    });
});

/* --------- REAL KEY DETECTION (FFT) --------- */
function detectKeyFFT(){
    if(!composer.audioCtx) return;

    let energy = new Array(12).fill(0);

    basePlayers.forEach(player=>{
        if(player && !player.paused){
            if(!player._analyser){
                const source = composer.audioCtx.createMediaElementSource(player);
                const analyser = composer.audioCtx.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);
                analyser.connect(composer.masterGain);
                player._analyser = analyser;
            }

            const buffer = new Uint8Array(player._analyser.frequencyBinCount);
            player._analyser.getByteFrequencyData(buffer);

            for(let i=0;i<buffer.length;i++){
                const freq = i * composer.audioCtx.sampleRate / player._analyser.fftSize;
                if(freq > 50 && freq < 2000){
                    const midi = Math.round(69 + 12*Math.log2(freq/440));
                    const pitch = ((midi%12)+12)%12;
                    energy[pitch] += buffer[i];
                }
            }
        }
    });

    const maxIndex = energy.indexOf(Math.max(...energy));
    const keys = Object.keys(noteMap);
    const found = keys.find(k=>noteMap[k]===maxIndex);
    if(found){
        detectedKey = found;
        const keySelect = document.getElementById("keySelect");
        if(keySelect) keySelect.value = detectedKey;
    }
}

/* --------- BAR SYNC --------- */
function getBarDuration(){
    if(!window.bpm) return 4;
    return (60/window.bpm) * 4;
}

function getNextBarDelay(){
    const now = composer.audioCtx.currentTime;
    const bar = getBarDuration();
    if(!globalBarStart) globalBarStart = now;
    const barsPassed = Math.ceil((now-globalBarStart)/bar);
    const nextBar = globalBarStart + barsPassed*bar;
    return Math.max(0, nextBar-now);
}

/* --------- STYLE PROGRESSIONS --------- */
function buildStyledProgression(){
    const root = noteMap[detectedKey];
    const base = 60 + root;

    if(harmonicStyle==="cinematic"){
        chordProgression = [base, base+5, base+3, base+7];
    }
    else if(harmonicStyle==="edm"){
        chordProgression = [base, base+7, base+5, base+3];
    }
    else if(harmonicStyle==="jazz"){
        chordProgression = [base, base+4, base+10, base+7];
    }
}

/* --------- PAD GENERATOR --------- */
function generatePad(chordRoot){
    const now = composer.audioCtx.currentTime;

    [0,3,7].forEach(interval=>{
        const osc = composer.audioCtx.createOscillator();
        const gain = composer.audioCtx.createGain();
        osc.type = "sawtooth";
        osc.frequency.value = composer.midiToFreq(chordRoot + interval);

        osc.connect(gain).connect(composer.masterGain);

        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now+3);

        osc.start();
        osc.stop(now+3.2);
    });
}

/* --------- ENERGY-BASED VARIATION --------- */
function getMovementEnergy(xNorm){
    return Math.abs(xNorm - 0.5)*2;
}

/* --------- Override play --------- */
const originalPlayV4 = composer.play.bind(composer);

composer.play = function(type, xNorm){

    const mode = document.getElementById("harmonicMode")?.value || "free";
    if(mode==="free"){
        originalPlayV4(type, xNorm);
        return;
    }

    detectKeyFFT();
    buildStyledProgression();

    const energy = getMovementEnergy(xNorm);

    const delay = getNextBarDelay()/4; // quantized to quarter beat

    const chordRoot = chordProgression[progressionIndex % chordProgression.length];
    progressionIndex++;

    const mainMidi = chordRoot + Math.floor(xNorm*12*(energy+0.5));

    setTimeout(()=>{
        this.createVoice(type, this.midiToFreq(mainMidi));
        generateDeepSub(chordRoot);
        generatePad(chordRoot);
    }, delay*1000);
};
</script>


<script>
/* ===================================== */
/*   HARMONIC ENGINE v4.1 â€“ SOFT MODE  */
/* ===================================== */

let lastTriggerTime = 0;
let minTriggerInterval = 0.18; // seconds (limits note spam)

function smoothEnergy(xNorm){
    // compress extreme movement
    return Math.pow(Math.abs(xNorm - 0.5)*2, 0.6);
}

const originalPlaySoft = composer.play.bind(composer);

composer.play = function(type, xNorm){

    const mode = document.getElementById("harmonicMode")?.value || "free";

    if(mode === "free"){
        originalPlaySoft(type, xNorm);
        return;
    }

    if(!composer.audioCtx) return;

    const now = composer.audioCtx.currentTime;

    // RATE LIMITER (prevents bouncing spam)
    if(now - lastTriggerTime < minTriggerInterval){
        return;
    }
    lastTriggerTime = now;

    detectKeyFFT();
    buildStyledProgression();

    const energy = smoothEnergy(xNorm);

    const delay = getNextBarDelay()/8; // softer quantization

    const chordRoot = chordProgression[progressionIndex % chordProgression.length];

    // DO NOT advance progression every trigger (only per bar feel)
    if(Math.random() < 0.3){
        progressionIndex++;
    }

    const mainMidi = chordRoot + Math.floor(xNorm*7*(energy+0.4));

    setTimeout(()=>{

        // Main voice softer envelope
        const freq = composer.midiToFreq(mainMidi);
        const osc = composer.audioCtx.createOscillator();
        const gain = composer.audioCtx.createGain();

        osc.type = type === "drums" ? "triangle" : type;
        osc.frequency.value = freq;

        osc.connect(gain).connect(composer.masterGain);

        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.2);

        osc.start();
        osc.stop(now + 1.3);

        // Sub bass softer
        generateDeepSub(chordRoot);

        // PAD only occasionally (prevents overload)
        if(Math.random() < 0.25){
            generatePad(chordRoot);
        }

    }, delay*1000);
};
</script>


<script>
/* ===================================================== */
/*   HARMONIC ENGINE v5 â€“ HYBRID ADAPTIVE GENERATOR    */
/* ===================================================== */

let hybridEnergy = 0;
let generatorInterval = null;
let lastXNorm = 0;

/* --- Store movement instead of triggering notes --- */
const originalPlayHybrid = composer.play.bind(composer);

composer.play = function(type, xNorm){
    const mode = document.getElementById("harmonicMode")?.value || "free";
    if(mode === "free"){
        originalPlayHybrid(type, xNorm);
        return;
    }
    lastXNorm = xNorm;
    hybridEnergy = Math.abs(xNorm - 0.5) * 2;
};

/* --- Adaptive Generator Loop --- */
function startHybridGenerator(){

    if(generatorInterval) clearInterval(generatorInterval);

    generatorInterval = setInterval(()=>{

        const mode = document.getElementById("harmonicMode")?.value || "free";
        if(mode !== "ai" || !composer.audioCtx) return;

        detectKeyFFT();
        buildStyledProgression();

        const chordRoot = chordProgression[progressionIndex % chordProgression.length];

        // Density adapts to energy
        const density = 1 + Math.floor(hybridEnergy * 3);

        for(let i=0;i<density;i++){

            const variation = Math.floor((lastXNorm - 0.5) * 12 * (hybridEnergy+0.3));
            const mainMidi = chordRoot + variation;

            composer.createVoice("triangle", composer.midiToFreq(mainMidi));

            // Sub layer stable
            generateDeepSub(chordRoot);

            // Texture layer based on energy
            if(hybridEnergy > 0.6){
                composer.createVoice("sawtooth", composer.midiToFreq(mainMidi+7));
            }
        }

        progressionIndex++;

    }, 350); // stable groove engine

}

document.addEventListener("DOMContentLoaded", ()=>{
    startHybridGenerator();
});
</script>


<script>
/* ===== GENRE â†’ HARMONIC STYLE ADAPTATION ===== */

function detectGenre(name){
name = name.toLowerCase();
if(name.includes("reggaeton")||name.includes("cumbiaton")||name.includes("hip"))
return "urban";
if(name.includes("cumbia")||name.includes("merengue")||name.includes("salsa")||name.includes("mambo")||name.includes("bachata"))
return "tropical";
if(name.includes("rock")||name.includes("80"))
return "rock";
if(name.includes("electronica")||name.includes("tribal"))
return "electronic";
if(name.includes("corridos")||name.includes("ranchera")||name.includes("duranguense")||name.includes("quebradita"))
return "regional";
if(name.includes("romantica"))
return "soft";
return "general";
}

function applyHarmonyByGenre(genre){
if(typeof harmonicStyle === "undefined") return;

switch(genre){
case "urban":
harmonicStyle = "edm";
break;
case "tropical":
harmonicStyle = "cinematic";
break;
case "rock":
harmonicStyle = "cinematic";
break;
case "electronic":
harmonicStyle = "edm";
break;
case "regional":
harmonicStyle = "cinematic";
break;
case "soft":
harmonicStyle = "jazz";
break;
default:
harmonicStyle = "cinematic";
}
console.log("IA adaptada a gÃ©nero:", genre, "â†’", harmonicStyle);
}

/* Patch toggleBase20 without breaking original system */
if(typeof toggleBase20 !== "undefined"){
const originalToggleBase20 = toggleBase20;
toggleBase20 = function(i, pad){
originalToggleBase20(i, pad);
if(baseActive && baseActive[i]){
const name = defaultBaseFiles[i] || "";
const genre = detectGenre(name);
applyHarmonyByGenre(genre);
}
}
}
</script>

</body>
</html>
