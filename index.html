
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BodyBeat v17</title>

<style>
body{margin:0;overflow:hidden;background:#050b18;font-family:Arial;}
video{display:none;}
canvas{position:absolute;width:100vw;height:100vh;}

#overlay{
position:absolute;top:0;left:0;width:100%;height:100%;
background:black;display:flex;align-items:center;justify-content:center;
color:white;font-size:22px;z-index:50;cursor:pointer;
}

#menuBtn{
position:fixed;
top:20px;
left:50%;
transform:translateX(-50%);
background:#0b1f3f;
border:2px solid #00e5ff;
padding:12px 22px;
border-radius:30px;
color:white;
cursor:pointer;
z-index:200;
box-shadow:0 0 15px #00e5ff;
}

#mainMenu{
position:fixed;top:50%;left:50%;
transform:translate(-50%,-50%);
background:#0b1f3f;border:3px solid #00e5ff;
border-radius:25px;padding:30px;display:none;
z-index:300;min-width:460px;color:white;
box-shadow:0 0 30px #00e5ff;
}

.menuButton{
width:100%;padding:12px;margin-top:10px;
border-radius:18px;border:2px solid #ff00ff;
background:#102a55;color:white;cursor:pointer;
box-shadow:0 0 12px #ff00ff;
}

.subPanel{max-height:85vh;overflow-y:auto;
position:fixed;top:50%;left:50%;
transform:translate(-50%,-50%);
background:#0a1833;border:3px solid #ff00ff;
border-radius:20px;padding:20px;
display:none;z-index:400;color:white;
min-width:360px;box-shadow:0 0 25px #ff00ff;
}

.closeBtn{position:absolute;top:10px;right:15px;cursor:pointer;font-size:20px;}
input[type=range]{width:100%;}

.assignGrid{
display:grid;
grid-template-columns:repeat(10,1fr);
gap:3px;margin-top:10px;
}

.assignCell{
height:26px;border:1px solid #00e5ff;
font-size:10px;display:flex;
align-items:center;justify-content:center;
cursor:pointer;
}

.sideCell{background:#003d2f;}
.centerCell{background:#111;}
.loaded{background:#6a00ff;}

#camSwitchBtn{
position:fixed;
bottom:25px;
left:50%;
transform:translateX(-50%);
background:#102a55;
border:2px solid #ff00ff;
padding:12px 22px;
border-radius:30px;
color:white;
cursor:pointer;
z-index:200;
box-shadow:0 0 12px #ff00ff;
}

video{
position:absolute;
top:0;
left:0;
width:1px;
height:1px;
opacity:0;
pointer-events:none;
}


button[onclick*="assignPanel"]{display:none !important;}
button[onclick*="loadPanel"]{display:none !important;}

</style>
</head>
<body>

<div id="overlay">Toca para activar sonido</div>
<button id="menuBtn">MENU</button>
<button id="camSwitchBtn">Cambiar Cámara</button>

<div id="mainMenu">
<h2 style="text-align:center;color:#e0c3ff;">BodyBeat Control</h2>
<button class="menuButton" onclick="openPanel('settingsPanel')">Configuración</button>
<button class="menuButton" onclick="openPanel('audioManagerPanel')">Carga y gestión de archivos de audio</button>
<button class="menuButton" onclick="openPanel('assignPanel')">Asignación por Cuadro</button>
<button class="menuButton" onclick="openPanel('loadPanel')">Carga Masiva</button>

<button class="menuButton" onclick="openModuleManager()">Módulos</button>

<button class="menuButton" onclick="toggleMirror()">Invertir Cámara</button>
<button class="menuButton" onclick="closeMain()">Cerrar</button>
</div>

<div id="settingsPanel" class="subPanel">
<div class="closeBtn" onclick="closePanel('settingsPanel')">✕</div>
<h3>Configuración</h3>
<label>Sensibilidad LED</label>
<input type="range" id="sensSlider" min="20" max="200" value="80"><br><br>
<label>Volumen</label>
<input type="range" id="volSlider" min="0" max="1" step="0.01" value="0.9"><br><br>
<button onclick="resetLoops()">Reset Loops</button>
</div>

<div id="assignPanel" class="subPanel">
<div class="closeBtn" onclick="closePanel('assignPanel')">✕</div>
<h3>Asignación Individual</h3>
<div class="assignGrid" id="assignGrid"></div>
<input type="file" id="fileSingle" accept="audio/*" hidden>
</div>

<div id="loadPanel" class="subPanel">
<div class="closeBtn" onclick="closePanel('loadPanel')">✕</div>
<h3>Carga Masiva</h3>
<button onclick="fileCenter.click()">Cargar Centro</button><br><br>
<button onclick="fileSides.click()">Cargar Laterales</button>
<input type="file" id="fileCenter" accept="audio/*" multiple hidden>
<input type="file" id="fileSides" accept="audio/*" multiple hidden>
</div>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<script>
const COLS=10, ROWS=8;
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const video=document.getElementById("video");

const analysisCanvas=document.createElement("canvas");
const analysisCtx=analysisCanvas.getContext("2d");

let audioContext, masterGain;
let activeLoops={};
let flashCells={};
let sensitivity=80;
let lastCenterCell=null;
let centerBuffers={};
let sideBuffers={};
let mirror=false;
const MAX_LOOPS=4;

/* AUDIO INIT */
overlay.onclick=()=>{
audioContext=new (window.AudioContext||window.webkitAudioContext)();
masterGain=audioContext.createGain();
masterGain.connect(audioContext.destination);
masterGain.gain.value=0.9;
overlay.style.display="none";
};


/* CAMERA */
let currentStream = null;
let currentFacing = "environment";
let isStartingCamera = false;

async function initCamera() {

    if (isStartingCamera) return;
    isStartingCamera = true;

    try {

        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
            await new Promise(r => setTimeout(r, 300));
        }

        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: currentFacing },
            audio: false
        });

        currentStream = stream;
        video.srcObject = stream;
        video.setAttribute("playsinline", true);
        video.muted = true;

        await video.play();

        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        analysisCanvas.width = video.videoWidth;
        analysisCanvas.height = video.videoHeight;

        startRendering();

    } catch (err) {
        console.error("Camera error:", err);
    }

    isStartingCamera = false;
}

function startRendering(){

    function renderFrame(){

        if(video.readyState >= 2){
            ctx.save();
            if(mirror){
                ctx.scale(-1,1);
                ctx.drawImage(video,-canvas.width,0,canvas.width,canvas.height);
            }else{
                ctx.drawImage(video,0,0,canvas.width,canvas.height);
            }
            ctx.restore();

            drawGrid();

            if(window.BodyBeat && BodyBeat.hooks && BodyBeat.hooks.afterDraw){
                BodyBeat.hooks.afterDraw.forEach(fn=>{
                    try{ fn(); }catch(e){ console.error("Hook error:", e); }
                });
            }
            if(window.BodyBeat){ BodyBeat.updateModules(0); }
            detectLight();
        }

        if(video.requestVideoFrameCallback){
            video.requestVideoFrameCallback(renderFrame);
        }else{
            requestAnimationFrame(renderFrame);
        }
    }

    if(video.requestVideoFrameCallback){
        video.requestVideoFrameCallback(renderFrame);
    }else{
        requestAnimationFrame(renderFrame);
    }
}

document.addEventListener("DOMContentLoaded", () => {

    initCamera();

    const btn = document.getElementById("camSwitchBtn");
    btn.onclick = async () => {
        currentFacing = currentFacing === "environment" ? "user" : "environment";
        await initCamera();
    };

});

function loop(){
ctx.save();
if(mirror){
ctx.scale(-1,1);
ctx.drawImage(video,-canvas.width,0,canvas.width,canvas.height);
}else{
ctx.drawImage(video,0,0,canvas.width,canvas.height);
}
ctx.restore();
drawGrid();

            if(window.BodyBeat && BodyBeat.hooks && BodyBeat.hooks.afterDraw){
                BodyBeat.hooks.afterDraw.forEach(fn=>{
                    try{ fn(); }catch(e){ console.error("Hook error:", e); }
                });
            }
            if(window.BodyBeat){ BodyBeat.updateModules(0); }
detectLight();
requestAnimationFrame(loop);
}

function drawGrid(){
const w=canvas.width/COLS;
const h=canvas.height/ROWS;

for(let r=0;r<ROWS;r++){
for(let c=0;c<COLS;c++){
let drawCol = mirror ? (COLS-1-c) : c;
let x=drawCol*w;
let y=r*h;
let key=r+"-"+c;

if(gridVisible){
    ctx.fillStyle=(c===0||c===COLS-1)?"#003d2f":"rgba(0,90,0,0.2)";
    ctx.fillRect(x,y,w,h);
}
    if(c===0||c===COLS-1){
        ctx.fillStyle="#00ffff";
        ctx.font="bold 14px Arial";
        ctx.fillText(r+1, x+5, y+20);
    }

if(activeLoops[key]){
ctx.fillStyle="rgba(0,255,180,0.4)";
ctx.fillRect(x,y,w,h);
    if(c===0||c===COLS-1){
        ctx.fillStyle="#00ffff";
        ctx.font="bold 14px Arial";
        ctx.fillText(r+1, x+5, y+20);
    }
}

if(flashCells[key]){
ctx.fillStyle="rgba(255,0,255,0.4)";
ctx.fillRect(x,y,w,h);
    if(c===0||c===COLS-1){
        ctx.fillStyle="#00ffff";
        ctx.font="bold 14px Arial";
        ctx.fillText(r+1, x+5, y+20);
    }
if(Date.now()-flashCells[key]>120) delete flashCells[key];
}

if(gridVisible){
    ctx.strokeStyle="rgba(0,255,255,0.6)";
    ctx.strokeRect(x,y,w,h);
}
}
}
}

/* CLICK */
canvas.addEventListener("click",e=>{
if(!audioContext) return;

const rect=canvas.getBoundingClientRect();
const scaleX=canvas.width/rect.width;
const scaleY=canvas.height/rect.height;
let x=(e.clientX-rect.left)*scaleX;
let y=(e.clientY-rect.top)*scaleY;

if(mirror) x = canvas.width - x;

const col=Math.floor(x/(canvas.width/COLS));
const row=Math.floor(y/(canvas.height/ROWS));
triggerCell(row,col);
});

function triggerCell(row,col){
let key=row+"-"+col;

if(col===0||col===COLS-1){
if(activeLoops[key]){activeLoops[key].stop();delete activeLoops[key];return;}
if(Object.keys(activeLoops).length>=MAX_LOOPS) return;

if(sideBuffers[row]){
let src=audioContext.createBufferSource();
src.buffer=sideBuffers[row];
src.loop=true;
src.connect(masterGain);
src.start();
activeLoops[key]=src;
}else{
let osc=audioContext.createOscillator();
osc.type="sawtooth";osc.frequency.value=80+row*15;
osc.connect(masterGain);osc.start();
activeLoops[key]=osc;
}
}else{
playCenter(row);
flashCells[key]=Date.now();
}
}

/* DETECCIÓN */
function detectLight(){
analysisCtx.drawImage(video,0,0);
let img=analysisCtx.getImageData(0,0,analysisCanvas.width,analysisCanvas.height);
let data=img.data;

let global=0;
for(let i=0;i<data.length;i+=40){
global+=data[i]+data[i+1]+data[i+2];
}
global/= (data.length/40);

const cellW=analysisCanvas.width/COLS;
const cellH=analysisCanvas.height/ROWS;

let best=null;
let bestScore=0;

for(let r=0;r<ROWS;r++){
for(let c=1;c<COLS-1;c++){
let total=0,count=0;
for(let y=r*cellH;y<(r+1)*cellH;y+=6){
for(let x=c*cellW;x<(c+1)*cellW;x+=6){
let idx=(Math.floor(y)*analysisCanvas.width+Math.floor(x))*4;
total+=data[idx]+data[idx+1]+data[idx+2];
count++;
}
}
let avg=total/count;
let contrast=avg-global;
if(contrast>bestScore){
bestScore=contrast;
best={row:r,col:c};
}
}
}

if(!best||bestScore<sensitivity) return;

let col = mirror ? (COLS-1-best.col) : best.col;
let key=best.row+"-"+col;

if(key!==lastCenterCell){
playCenter(best.row);
flashCells[key]=Date.now();
lastCenterCell=key;
}
}

function playCenter(row){
if(centerBuffers[row]){
let src=audioContext.createBufferSource();
src.buffer=centerBuffers[row];
src.connect(masterGain);
src.start();
}else{
let osc=audioContext.createOscillator();
osc.type="triangle";osc.frequency.value=300+row*30;
osc.connect(masterGain);osc.start();
osc.stop(audioContext.currentTime+0.2);
}
}

/* ASSIGN GRID */
const assignGrid=document.getElementById("assignGrid");
let selectedCell=null;

function buildAssign(){
assignGrid.innerHTML="";
for(let r=0;r<ROWS;r++){
for(let c=0;c<COLS;c++){
let div=document.createElement("div");
div.className="assignCell "+(c===0||c===COLS-1?"sideCell":"centerCell");
if(centerBuffers[r]&&c>0&&c<COLS-1) div.classList.add("loaded");
if(sideBuffers[r]&&(c===0||c===COLS-1)) div.classList.add("loaded");
div.innerText=r+"-"+c;
div.onclick=()=>{selectedCell={r,c};fileSingle.click();};
assignGrid.appendChild(div);
}
}
}
buildAssign();

fileSingle.onchange=e=>{
let file=e.target.files[0];
if(!file||!selectedCell) return;
let reader=new FileReader();
reader.onload=ev=>{
audioContext.decodeAudioData(ev.target.result,b=>{
if(selectedCell.c===0||selectedCell.c===COLS-1)
sideBuffers[selectedCell.r]=b;
else
centerBuffers[selectedCell.r]=b;
buildAssign();
});
};
reader.readAsArrayBuffer(file);
};

fileCenter.onchange=e=>{
[...e.target.files].forEach((f,i)=>{
let reader=new FileReader();
reader.onload=ev=>audioContext.decodeAudioData(ev.target.result,b=>centerBuffers[i]=b);
reader.readAsArrayBuffer(f);
});
};

fileSides.onchange=e=>{
[...e.target.files].forEach((f,i)=>{
let reader=new FileReader();
reader.onload=ev=>audioContext.decodeAudioData(ev.target.result,b=>sideBuffers[i]=b);
reader.readAsArrayBuffer(f);
});
};

/* UI */
function openPanel(id){document.getElementById(id).style.display="block";}
function closePanel(id){document.getElementById(id).style.display="none";}
function closeMain(){mainMenu.style.display="none";}

menuBtn.onclick=()=>{
    if(mainMenu.style.display==="block"){
        mainMenu.style.display="none";
    }else{
        mainMenu.style.display="block";
    }
};

sensSlider.oninput=e=>sensitivity=parseInt(e.target.value);
volSlider.oninput=e=>{if(masterGain) masterGain.gain.value=parseFloat(e.target.value);};

function resetLoops(){
for(let k in activeLoops){try{activeLoops[k].stop();}catch(e){}}
activeLoops={};
}

function toggleMirror(){mirror=!mirror;}

function openModulePanel(){
    document.getElementById('modulePanel').style.display='block';
}



// ================== DEMO PRO LOOP ENGINE (LATERALS) ==================

let demoActiveEngines = {};

function startDemoEngine(row){

    if(demoActiveEngines[row]){
        demoActiveEngines[row].stop();
        delete demoActiveEngines[row];
        return;
    }

    const styles = [
        {bpm:130, type:"techno"},
        {bpm:124, type:"house"},
        {bpm:140, type:"trap"},
        {bpm:92,  type:"hiphop"},
        {bpm:170, type:"dnb"},
        {bpm:95,  type:"reggaeton"},
        {bpm:110, type:"rock"},
        {bpm:100, type:"ambient"}
    ];

    const style = styles[row];
    const engine = createDemoSequencer(style.bpm, style.type);
    engine.start();
    demoActiveEngines[row] = engine;
}

function createDemoSequencer(bpm,type){

    let currentStep = 0;
    let nextNoteTime = 0;
    const steps = 16;
    const lookAhead = 0.1;
    const intervalTime = 25;
    const stepTime = (60/bpm)/4;
    let timer;

    function schedule(){
        while(nextNoteTime < audioContext.currentTime + lookAhead){
            playStep(currentStep, nextNoteTime);
            nextNoteTime += stepTime;
            currentStep = (currentStep+1)%steps;
        }
    }

    function start(){
        nextNoteTime = audioContext.currentTime;
        timer = setInterval(schedule, intervalTime);
    }

    function stop(){
        clearInterval(timer);
    }

    function playStep(step,time){

        function kick(vol){
            let osc=audioContext.createOscillator();
            let gain=audioContext.createGain();
            osc.type="sine";
            osc.frequency.setValueAtTime(150,time);
            osc.frequency.exponentialRampToValueAtTime(40,time+0.15);
            gain.gain.setValueAtTime(vol,time);
            gain.gain.exponentialRampToValueAtTime(0.001,time+0.2);
            osc.connect(gain).connect(masterGain);
            osc.start(time);
            osc.stop(time+0.2);
        }

        function snare(){
            let noise=audioContext.createBufferSource();
            let buffer=audioContext.createBuffer(1,44100,44100);
            let data=buffer.getChannelData(0);
            for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
            noise.buffer=buffer;
            let gain=audioContext.createGain();
            gain.gain.setValueAtTime(0.4,time);
            gain.gain.exponentialRampToValueAtTime(0.001,time+0.2);
            noise.connect(gain).connect(masterGain);
            noise.start(time);
            noise.stop(time+0.2);
        }

        function hat(vol){
            let osc=audioContext.createOscillator();
            let gain=audioContext.createGain();
            osc.type="square";
            osc.frequency.value=8000;
            gain.gain.setValueAtTime(vol,time);
            gain.gain.exponentialRampToValueAtTime(0.001,time+0.05);
            osc.connect(gain).connect(masterGain);
            osc.start(time);
            osc.stop(time+0.05);
        }

        switch(type){

            case "techno":
                if(step%4===0) kick(0.9);
                if(step%8===4) snare();
                if(step%2===1) hat(0.2);
            break;

            case "house":
                if(step%4===0) kick(0.8);
                if(step%4===2) snare();
                if(step%2===1) hat(0.15);
            break;

            case "trap":
                if(step%4===0) kick(0.9);
                if(step===6||step===14) snare();
                if(step%2===1) hat(0.1);
            break;

            case "hiphop":
                if(step%4===0) kick(0.8);
                if(step===4||step===12) snare();
                if(step%2===1) hat(0.12);
            break;

            case "dnb":
                if(step%2===0) kick(0.7);
                if(step%4===2) snare();
                hat(0.08);
            break;

            case "reggaeton":
                if(step%4===0||step%4===2) kick(0.85);
                if(step===6||step===14) snare();
                hat(0.1);
            break;

            case "rock":
                if(step%4===0) kick(0.9);
                if(step%4===2) snare();
                if(step%2===1) hat(0.2);
            break;

            case "ambient":
                if(step%8===0) kick(0.4);
                if(step%4===2) hat(0.05);
            break;
        }
    }

    return {start,stop};
}

// Override lateral trigger behavior if no audio loaded
const originalTriggerCell = triggerCell;
triggerCell = function(row,col){

    if(col===0 || col===COLS-1){
        startDemoEngine(row);
        return;
    }

    originalTriggerCell(row,col);
};




// ================= SAFE PRO ENGINE =================

let proEngines = {};
let activeLeftPro = [];
let activeRightPro = [];


function createProEngine(index){

    const styles=[
        "Techno Industrial",
        "Deep House",
        "Trap Dark",
        "Boom Bap",
        "Drum & Bass",
        "Reggaeton",
        "Electro Rock",
        "Ambient Pulse"
    ];

    const style = styles[index % styles.length];

    const bpms=[132,124,140,92,170,96,110,100];
    const bpm = bpms[index % bpms.length];

    let step=0;
    let nextTime=0;
    const stepTime=(60/bpm)/4;
    let timer;

    function kick(time,power=1){
        let osc=audioContext.createOscillator();
        let gain=audioContext.createGain();
        osc.type="sine";
        osc.frequency.setValueAtTime(180,time);
        osc.frequency.exponentialRampToValueAtTime(45,time+0.12);
        gain.gain.setValueAtTime(1.2*power,time);
        gain.gain.exponentialRampToValueAtTime(0.001,time+0.25);
        osc.connect(gain).connect(masterGain);
        osc.start(time);
        osc.stop(time+0.25);
    }

    function snare(time){
        let buffer=audioContext.createBuffer(1,44100,44100);
        let data=buffer.getChannelData(0);
        for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
        let src=audioContext.createBufferSource();
        src.buffer=buffer;
        let band=audioContext.createBiquadFilter();
        band.type="bandpass";
        band.frequency.value=2000;
        let gain=audioContext.createGain();
        gain.gain.setValueAtTime(0.6,time);
        gain.gain.exponentialRampToValueAtTime(0.001,time+0.2);
        src.connect(band).connect(gain).connect(masterGain);
        src.start(time);
        src.stop(time+0.2);
    }

    function hat(time,vol=0.2){
        let osc=audioContext.createOscillator();
        let gain=audioContext.createGain();
        osc.type="square";
        osc.frequency.value=8000+Math.random()*1000;
        gain.gain.setValueAtTime(vol,time);
        gain.gain.exponentialRampToValueAtTime(0.001,time+0.05);
        osc.connect(gain).connect(masterGain);
        osc.start(time);
        osc.stop(time+0.05);
    }

    function schedule(){
        while(nextTime<audioContext.currentTime+0.1){

            switch(style){

                case "Techno Industrial":
                    if(step%4===0) kick(nextTime,1.1);
                    if(step%8===4) snare(nextTime);
                    hat(nextTime,0.15);
                break;

                case "Deep House":
                    if(step%4===0) kick(nextTime,0.9);
                    if(step%4===2) snare(nextTime);
                    if(step%2===1) hat(nextTime,0.12);
                break;

                case "Trap Dark":
                    if(step%4===0) kick(nextTime,1.2);
                    if(step===6||step===14) snare(nextTime);
                    if(step%2===1) hat(nextTime,0.08);
                break;

                case "Boom Bap":
                    if(step%4===0) kick(nextTime,1);
                    if(step===4||step===12) snare(nextTime);
                    if(step%4===1) hat(nextTime,0.18);
                break;

                case "Drum & Bass":
                    if(step%2===0) kick(nextTime,0.8);
                    if(step%4===2) snare(nextTime);
                    hat(nextTime,0.1);
                break;

                case "Reggaeton":
                    if(step%4===0||step%4===2) kick(nextTime,1);
                    if(step===6||step===14) snare(nextTime);
                    if(step%2===1) hat(nextTime,0.12);
                break;

                case "Electro Rock":
                    if(step%4===0) kick(nextTime,1.1);
                    if(step%4===2) snare(nextTime);
                    if(step%2===1) hat(nextTime,0.2);
                break;

                case "Ambient Pulse":
                    if(step%8===0) kick(nextTime,0.4);
                    if(step%4===2) hat(nextTime,0.05);
                break;
            }

            nextTime+=stepTime;
            step=(step+1)%16;
        }
    }

    return {
        start(){
            nextTime=audioContext.currentTime;
            timer=setInterval(schedule,25);
        },
        stop(){
            clearInterval(timer);
        }
    };
}


// Safe override triggerCell (only laterals)
const originalTriggerCellSafe = triggerCell;

triggerCell = function(row,col){

    if(col===0||col===COLS-1){

        const isLeft = col===0;
        const key = (isLeft?"L":"R")+row;
        let sideArr = isLeft?activeLeftPro:activeRightPro;

        if(proEngines[key]){
            proEngines[key].stop();
            delete proEngines[key];
            sideArr.splice(sideArr.indexOf(key),1);
            return;
        }

        if(sideArr.length>=2){
            const oldest=sideArr.shift();
            proEngines[oldest].stop();
            delete proEngines[oldest];
        }

        const engine=createProEngine(row+(isLeft?0:8));
        engine.start();
        proEngines[key]=engine;
        sideArr.push(key);
        return;
    }

    originalTriggerCellSafe(row,col);
};

// Visual highlight hook (augment drawGrid safely)
const originalDrawGridSafe = drawGrid;

drawGrid = function(){
    originalDrawGridSafe();

    const w=canvas.width/COLS;
    const h=canvas.height/ROWS;

    for(let r=0;r<ROWS;r++){

        if(proEngines["L"+r]){
            ctx.fillStyle="rgba(0,150,255,0.6)";
            ctx.fillRect(0,r*h,w,h);
        }

        if(proEngines["R"+r]){
            ctx.fillStyle="rgba(0,255,150,0.6)";
            ctx.fillRect((COLS-1)*w,r*h,w,h);
        }

        ctx.fillStyle="#00ffff";
        ctx.font="bold 14px Arial";
        const letters=["A","B","C","D","E","F","G","H"];
        ctx.fillText(letters[r],5,r*h+20);
        ctx.fillText(r+1,(COLS-1)*w+5,r*h+20);
    }
};






// ================= AUDIO MANAGER SYSTEM (FIXED CLEAN) =================

let tempCellBuffers = {};
let selectedManagerCell = null;

function buildAudioManagerGrid(){
    const grid = document.getElementById("audioManagerGrid");
    if(!grid) return;
    grid.innerHTML = "";

    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){

            let div=document.createElement("div");
            div.className="assignCell "+(c===0||c===COLS-1?"sideCell":"centerCell");

            const cellKey = r + "-" + c;

            const hasTemp = tempCellBuffers[cellKey] !== undefined;

            const hasFinal = (c===0||c===COLS-1)
                ? (sideBuffers[r] !== undefined && (c===0||c===COLS-1))
                : (centerBuffers[r] !== undefined);

            if(hasTemp || hasFinal){
                div.classList.add("loaded");
            }

            div.innerText=r+"-"+c;
            div.onclick=()=>openSingleLoader(r,c);
            grid.appendChild(div);
        }
    }
}

function openSingleLoader(r,c){

    selectedManagerCell={r,c};

    const useLocal = confirm("Aceptar = Archivo local\nCancelar = Cargar por link");

    if(useLocal){

        const input=document.getElementById("audioFileInput");
        input.multiple=false;
        input.value="";
        input.onchange=function(e){
            const file=e.target.files[0];
            if(!file) return;

            const reader=new FileReader();
            reader.onload=ev=>{
                audioContext.decodeAudioData(ev.target.result,b=>{
                    tempCellBuffers[r+"-"+c] = b;
                    buildAudioManagerGrid();
                });
            };
            reader.readAsArrayBuffer(file);
        };

        input.click();

    }else{

        const url=prompt("Pega el link del audio:");
        if(!url) return;

        fetch(url)
        .then(r=>r.arrayBuffer())
        .then(buf=>{
            audioContext.decodeAudioData(buf,b=>{
                tempCellBuffers[r+"-"+c] = b;
                buildAudioManagerGrid();
            });
        });
    }
}

/* ===== SEQUENTIAL BATCH LOADER FIX ===== */

let batchPointerCenter = 0;
let batchPointerLeft = 0;
let batchPointerRight = 0;

function getNextCenterCell(){
    while(batchPointerCenter < ROWS*(COLS-2)){
        const r = Math.floor(batchPointerCenter / (COLS-2));
        const c = 1 + (batchPointerCenter % (COLS-2));
        batchPointerCenter++;
        return {r,c};
    }
    return null;
}

function getNextSideCell(side){
    if(side==="left"){
        if(batchPointerLeft < ROWS){
            return {r: batchPointerLeft++, c:0};
        }
    }
    if(side==="right"){
        if(batchPointerRight < ROWS){
            return {r: batchPointerRight++, c:COLS-1};
        }
    }
    return null;
}

function openMassLoader(type){

    if(!audioContext){
        audioContext = new (window.AudioContext||window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        masterGain.gain.value = 0.9;
    }

    const input=document.getElementById("audioFileInput");
    input.multiple=true;
    input.value="";

    input.onchange=function(e){

        const files=[...e.target.files];

        files.forEach(file=>{

            const reader=new FileReader();

            reader.onload=function(ev){

                audioContext.decodeAudioData(ev.target.result).then(buffer=>{

                    let cell;

                    if(type==="center"){
                        cell = getNextCenterCell();
                    }

                    if(type==="left"){
                        cell = getNextSideCell("left");
                    }

                    if(type==="right"){
                        cell = getNextSideCell("right");
                    }

                    if(!cell) return;

                    // ENGINE (by row)
                    if(cell.c===0||cell.c===COLS-1){
                        sideBuffers[cell.r]=buffer;
                    }else{
                        centerBuffers[cell.r]=buffer;
                    }

                    // VISUAL (by cell)
                    visualLoadedCells[cell.r+"-"+cell.c]=true;

                    rebuildAudioManagerVisual();
                    buildAssign();

                });

            };

            reader.readAsArrayBuffer(file);

        });

    };

    input.click();
}

function saveAudioManager(){

    
    for(const key in tempCellBuffers){
        const [r,c] = key.split("-").map(Number);
        if(c===0||c===COLS-1){
            sideBuffers[r] = tempCellBuffers[key];
        }else{
            centerBuffers[r] = tempCellBuffers[key];
        }
    }
    tempCellBuffers = {};
    

    buildAssign();
    buildAudioManagerGrid();
    closePanel('audioManagerPanel');
}

document.addEventListener("DOMContentLoaded",()=>{
    buildAudioManagerGrid();
});




/* ===== ISOLATED VISUAL AUDIO MANAGER FIX ===== */

let visualLoadedCells = {};

// Safe wrapper to rebuild only visual marks
function rebuildAudioManagerVisual(){

    const grid = document.getElementById("audioManagerGrid");
    if(!grid) return;

    const cells = grid.querySelectorAll(".assignCell");

    cells.forEach(cell=>{
        const key = cell.innerText.trim();
        if(visualLoadedCells[key]){
            cell.classList.add("loaded");
        }
    });
}

// Hook into existing openSingleLoader safely
const __originalOpenSingleLoader = openSingleLoader;

openSingleLoader = function(r,c){

    if(!audioContext){
        audioContext = new (window.AudioContext||window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        masterGain.gain.value = 0.9;
    }

    const input=document.getElementById("audioFileInput");
    input.multiple=false;
    input.value="";

    input.onchange=function(e){

        const file=e.target.files[0];
        if(!file) return;

        const reader=new FileReader();

        reader.onload=function(ev){

            audioContext.decodeAudioData(ev.target.result).then(buffer=>{

                // Keep engine by row (original logic)
                if(c===0||c===COLS-1){
                    sideBuffers[r]=buffer;
                }else{
                    centerBuffers[r]=buffer;
                }

                // Mark ONLY visual cell
                visualLoadedCells[r+"-"+c]=true;

                rebuildAudioManagerVisual();
                buildAssign();

            });

        };

        reader.readAsArrayBuffer(file);
    };

    input.click();
};




/* ===== FINAL SAFE OVERRIDE: CENTER LIGHT ONLY ===== */

const __finalOriginalTriggerCell = triggerCell;

triggerCell = function(row,col){
    // Block center from mouse (light detection does NOT use triggerCell)
    if(col>0 && col<COLS-1){
        return;
    }
    __finalOriginalTriggerCell(row,col);
};




/* ===== CENTER LIGHT GATED PLAYBACK ===== */


/* ===== CENTER INSTRUMENT ENGINE ===== */

let activeCenterSources = {};

function playCenter(row){

    // Stop previous if exists
    if(activeCenterSources[row]){
        try{ activeCenterSources[row].stop(); }catch(e){}
        delete activeCenterSources[row];
    }

    let src;

    // If user loaded audio → use it
    if(centerBuffers[row]){
        src = audioContext.createBufferSource();
        src.buffer = centerBuffers[row];
        src.loop = true;
        src.connect(masterGain);
        src.start();
        activeCenterSources[row] = src;
        return;
    }

    // Otherwise generate instrument by row
    const instruments = [
        "triangle","sawtooth","square","sine",
        "triangle","sawtooth","square","sine"
    ];

    const baseFrequencies = [220,246,261,293,329,349,392,440];

    let osc = audioContext.createOscillator();
    let gain = audioContext.createGain();

    osc.type = instruments[row % instruments.length];
    osc.frequency.value = baseFrequencies[row % baseFrequencies.length];

    gain.gain.value = 0.6;

    osc.connect(gain).connect(masterGain);
    osc.start();

    activeCenterSources[row] = osc;
}


// Stop center sounds if no light detected
const __originalDetectLight = detectLight;

detectLight = function(){

    analysisCtx.drawImage(video,0,0);
    let img=analysisCtx.getImageData(0,0,analysisCanvas.width,analysisCanvas.height);
    let data=img.data;

    let global=0;
    for(let i=0;i<data.length;i+=40){
        global+=data[i]+data[i+1]+data[i+2];
    }
    global/= (data.length/40);

    const cellW=analysisCanvas.width/COLS;
    const cellH=analysisCanvas.height/ROWS;

    let best=null;
    let bestScore=0;

    for(let r=0;r<ROWS;r++){
        for(let c=1;c<COLS-1;c++){
            let total=0,count=0;
            for(let y=r*cellH;y<(r+1)*cellH;y+=6){
                for(let x=c*cellW;x<(c+1)*cellW;x+=6){
                    let idx=(Math.floor(y)*analysisCanvas.width+Math.floor(x))*4;
                    total+=data[idx]+data[idx+1]+data[idx+2];
                    count++;
                }
            }
            let avg=total/count;
            let contrast=avg-global;
            if(contrast>bestScore){
                bestScore=contrast;
                best={row:r,col:c};
            }
        }
    }

    // If no strong light → stop all center sounds
    if(!best || bestScore < sensitivity){
        for(let r in activeCenterSources){
            try{ activeCenterSources[r].stop(); }catch(e){}
        }
        activeCenterSources = {};
        return;
    }

    let col = mirror ? (COLS-1-best.col) : best.col;
    let row = best.row;

    if(!activeCenterSources[row]){
        playCenter(row);
    }

};




/* ===== FIX: PREVENT AUTO PLAY DURING MASS LOAD ===== */

let tempCenterBatch = {};
let tempSideBatch = {};

// Override mass loader so it does NOT touch engine buffers yet
const __originalOpenMassLoader_v13 = openMassLoader;

openMassLoader = function(type){

    if(!audioContext){
        audioContext = new (window.AudioContext||window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        masterGain.gain.value = 0.9;
    }

    const input=document.getElementById("audioFileInput");
    input.multiple=true;
    input.value="";

    input.onchange=function(e){

        const files=[...e.target.files];

        files.forEach(file=>{

            const reader=new FileReader();

            reader.onload=function(ev){

                audioContext.decodeAudioData(ev.target.result).then(buffer=>{

                    let cell;

                    if(type==="center"){
                        cell = getNextCenterCell();
                    }

                    if(type==="left"){
                        cell = getNextSideCell("left");
                    }

                    if(type==="right"){
                        cell = getNextSideCell("right");
                    }

                    if(!cell) return;

                    // STORE TEMP (NOT ENGINE YET)
                    if(cell.c===0||cell.c===COLS-1){
                        tempSideBatch[cell.r]=buffer;
                    }else{
                        tempCenterBatch[cell.r]=buffer;
                    }

                    visualLoadedCells[cell.r+"-"+cell.c]=true;
                    rebuildAudioManagerVisual();

                });

            };

            reader.readAsArrayBuffer(file);

        });

    };

    input.click();
};

// Override save to commit buffers to engine
const __originalSaveAudioManager_v13 = saveAudioManager;

saveAudioManager = function(){

    for(let r in tempCenterBatch){
        centerBuffers[r]=tempCenterBatch[r];
    }

    for(let r in tempSideBatch){
        sideBuffers[r]=tempSideBatch[r];
    }

    tempCenterBatch={};
    tempSideBatch={};

    buildAssign();
    closePanel('audioManagerPanel');
};



/* ===== PULSING SOLID CENTER HIGHLIGHT ===== */

let currentLightCell = null;

// Override detectLight again to track exact active cell
const __detectLightWithVisual = detectLight;

detectLight = function(){

    analysisCtx.drawImage(video,0,0);
    let img=analysisCtx.getImageData(0,0,analysisCanvas.width,analysisCanvas.height);
    let data=img.data;

    let global=0;
    for(let i=0;i<data.length;i+=40){
        global+=data[i]+data[i+1]+data[i+2];
    }
    global/= (data.length/40);

    const cellW=analysisCanvas.width/COLS;
    const cellH=analysisCanvas.height/ROWS;

    let best=null;
    let bestScore=0;

    for(let r=0;r<ROWS;r++){
        for(let c=1;c<COLS-1;c++){
            let total=0,count=0;
            for(let y=r*cellH;y<(r+1)*cellH;y+=6){
                for(let x=c*cellW;x<(c+1)*cellW;x+=6){
                    let idx=(Math.floor(y)*analysisCanvas.width+Math.floor(x))*4;
                    total+=data[idx]+data[idx+1]+data[idx+2];
                    count++;
                }
            }
            let avg=total/count;
            let contrast=avg-global;
            if(contrast>bestScore){
                bestScore=contrast;
                best={row:r,col:c};
            }
        }
    }

    if(!best || bestScore < sensitivity){
        for(let r in activeCenterSources){
            try{ activeCenterSources[r].stop(); }catch(e){}
        }
        activeCenterSources = {};
        currentLightCell = null;
        return;
    }

    let col = mirror ? (COLS-1-best.col) : best.col;
    let row = best.row;

    currentLightCell = {row: row, col: col};

    if(!activeCenterSources[row]){
        playCenter(row);
    }
};

// Enhance drawGrid to add pulsing solid highlight
const __drawGridWithPulse = drawGrid;

drawGrid = function(){

    __drawGridWithPulse();

    if(!currentLightCell) return;

    const w=canvas.width/COLS;
    const h=canvas.height/ROWS;

    const r=currentLightCell.row;
    const c=currentLightCell.col;

    const x=c*w;
    const y=r*h;

    // Pulsing brightness
    const pulse = 0.5 + 0.5 * Math.sin(Date.now()/180);
    const green = Math.floor(200 + 55*pulse);

    ctx.fillStyle = "rgb(0," + green + ",255)";
    ctx.fillRect(x,y,w,h);

    ctx.strokeStyle="white";
    ctx.lineWidth=3;
    ctx.strokeRect(x,y,w,h);
};


/* ===== CLEAR AUDIO GRID FUNCTION ===== */

function clearAudioGrid(){

    // Stop all active center sounds
    for(let r in activeCenterSources){
        try{ activeCenterSources[r].stop(); }catch(e){}
    }
    activeCenterSources = {};

    // Stop lateral engines
    for(let key in proEngines){
        try{ proEngines[key].stop(); }catch(e){}
    }
    proEngines = {};
    activeLeftPro = [];
    activeRightPro = [];

    // Clear buffers
    centerBuffers = {};
    sideBuffers = {};
    tempCenterBatch = {};
    tempSideBatch = {};
    tempCellBuffers = {};
    visualLoadedCells = {};

    buildAssign();
    buildAudioManagerGrid();
}


/* ===============================
   BODYBEAT CORE API (v1)
   =============================== */

window.BodyBeat = {

    version: "1.0.0-core",
    modules: {},
    activeModules: {},

    core: {
        getAudioContext: () => audioContext,
        getMasterGain: () => masterGain,
        getCanvas: () => canvas,
        getContext: () => ctx,
        getGridSize: () => ({ rows: ROWS, cols: COLS })
    },

    registerModule(module){

        if(!module.id){
            console.warn("Module must have an id");
            return;
        }

        if(this.modules[module.id]){
            console.warn("Module already registered:", module.id);
            return;
        }

        this.modules[module.id] = module;
        console.log("Module registered:", module.id);
    },

    activateModule(id){

        const module = this.modules[id];
        if(!module) return;

        if(this.activeModules[id]) return;

        try{
            module.init?.(this.core);
            this.activeModules[id] = module;
            module.active = true;
            console.log("Module activated:", id);
        }catch(e){
            console.error("Module activation error:", id, e);
        }
    },

    deactivateModule(id){

        const module = this.activeModules[id];
        if(!module) return;

        try{
            module.destroy?.();
            delete this.activeModules[id];
            module.active = false;
            console.log("Module deactivated:", id);
        }catch(e){
            console.error("Module destroy error:", id, e);
        }
    },

    updateModules(delta){

        for(const id in this.activeModules){
            try{
                this.activeModules[id].update?.(delta);
            }catch(e){
                console.error("Module update error:", id, e);
            }
        }
    }
};


/* ===============================
   MODULE MANAGER (v1)
   =============================== */

function openModuleManager(){
    document.getElementById("moduleManagerPanel").style.display = "block";
    renderModuleList();
}

function renderModuleList(){

    const container = document.getElementById("moduleList");
    container.innerHTML = "";

    for(const id in BodyBeat.modules){

        const module = BodyBeat.modules[id];

        const row = document.createElement("div");
        row.style.marginBottom = "8px";

        const label = document.createElement("span");
        label.innerText = module.name || id;

        const btn = document.createElement("button");
        btn.style.marginLeft = "10px";

        if(BodyBeat.activeModules[id]){
            btn.innerText = "Desactivar";
            btn.onclick = () => {
                BodyBeat.deactivateModule(id);
                renderModuleList();
            };
        }else{
            btn.innerText = "Activar";
            btn.onclick = () => {
                BodyBeat.activateModule(id);
                renderModuleList();
            };
        }

        row.appendChild(label);
        row.appendChild(btn);
        container.appendChild(row);
    }
}

/* ---- Cargar módulo externo ---- */

document.addEventListener("DOMContentLoaded",()=>{

    const input = document.getElementById("moduleFileInput");

    input.addEventListener("change", function(){

        const file = this.files[0];
        if(!file) return;

        const script = document.createElement("script");
        script.src = URL.createObjectURL(file);

        script.onload = () => { script.dataset.moduleId = Object.keys(BodyBeat.modules).slice(-1)[0];
            console.log("External module loaded");
            renderModuleList();
        };

        document.body.appendChild(script);
    });

});

/* ---- Guardar estado ---- */

function saveModuleState(){

    const activeIds = Object.keys(BodyBeat.activeModules);
    localStorage.setItem("bb_active_modules", JSON.stringify(activeIds));

    alert("Configuración guardada");
}

/* ---- Restaurar estado ---- */

window.addEventListener("DOMContentLoaded",()=>{

    const saved = localStorage.getItem("bb_active_modules");
    if(!saved) return;

    const ids = JSON.parse(saved);

    ids.forEach(id=>{
        if(BodyBeat.modules[id]){
            BodyBeat.activateModule(id);
        }
    });
});


/* ===== SAFE MODULE PANEL SUPPORT v2.1 ===== */

function openModulePanelFor(id){

    const module = BodyBeat.modules[id];
    if(!module) return;

    if(module.hasPanel && typeof module.renderPanel === "function"){
        module.renderPanel();
    }else{
        alert("Este módulo no tiene panel configurable.");
    }
}


/* ===== SAFE OVERRIDE: renderModuleList buttons only ===== */

const __originalRenderModuleList = renderModuleList;

renderModuleList = function(){

    const container = document.getElementById("moduleList");
    container.innerHTML = "";

    for(const id in BodyBeat.modules){

        const module = BodyBeat.modules[id];

        const btn = document.createElement("button");
        btn.className = "menuButton";
        btn.style.marginBottom = "8px";
        btn.innerText = module.name || id;

        btn.onclick = () => openModulePanelFor(id);

        container.appendChild(btn);
    }
};


/* ===============================
   BODYBEAT VISUAL HOOK SYSTEM
   =============================== */

if(!window.BodyBeat.hooks){
    BodyBeat.hooks = {
        afterDraw: []
    };

    BodyBeat.onAfterDraw = function(fn){
        if(typeof fn === "function"){
            this.hooks.afterDraw.push(fn);
        }
    };

    BodyBeat.clearAfterDrawHooks = function(){
        this.hooks.afterDraw = [];
    };
}


/* ===============================
   MODULE DELETE SYSTEM
   =============================== */

function openDeleteModulesPanel(){

    document.getElementById("deleteModulesPanel").style.display = "block";
    const container = document.getElementById("deleteModulesList");
    container.innerHTML = "";

    for(const id in BodyBeat.modules){

        const row = document.createElement("div");

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = id;
        checkbox.className = "deleteModuleCheckbox";

        const label = document.createElement("label");
        label.innerText = " " + (BodyBeat.modules[id].name || id);

        row.appendChild(checkbox);
        row.appendChild(label);

        container.appendChild(row);
    }
}

function confirmDeleteModules(){

    const checkboxes = document.querySelectorAll(".deleteModuleCheckbox:checked");

    checkboxes.forEach(cb=>{

        const id = cb.value;

        // Deactivate if active
        if(BodyBeat.activeModules[id]){
            BodyBeat.deactivateModule(id);
        }

        // Remove module
        removeModuleScript(id);
        delete BodyBeat.modules[id];

        // Remove possible localStorage config
        localStorage.removeItem("bb_" + id + "_config");

    });

    closePanel("deleteModulesPanel");
    renderModuleList();
}


/* ===== GRID VISIBILITY CONTROL ===== */
let gridVisible = true;

function toggleGridVisibility(){
    gridVisible = !gridVisible;
}


/* ===============================
   BODYBEAT AUDIO BUS SYSTEM
   =============================== */

if(window.BodyBeat && !BodyBeat.audioBusInitialized){

    BodyBeat.audioBusInitialized = true;

    const originalGetMaster = BodyBeat.core.getMasterGain;
    const originalGetAudio = BodyBeat.core.getAudioContext;

    BodyBeat.fxBus = null;

    BodyBeat.core.getFxBus = function(){
        return BodyBeat.fxBus;
    };

    // Initialize bus once AudioContext exists
    const checkBus = setInterval(()=>{

        const ctx = originalGetAudio();
        const master = originalGetMaster();

        if(ctx && master && !BodyBeat.fxBus){

            BodyBeat.fxBus = ctx.createGain();

            master.disconnect();
            master.connect(BodyBeat.fxBus);
            BodyBeat.fxBus.connect(ctx.destination);

            clearInterval(checkBus);
            console.log("FX Bus initialized");
        }

    }, 300);

}


/* ===== IMPROVED MODULE DELETE CLEANUP ===== */

function removeModuleScript(id){
    document.querySelectorAll("script").forEach(s=>{
        if(s.dataset && s.dataset.moduleId === id){
            s.remove();
        }
    });
}


/* ===============================
   BODYBEAT AUDIO ARCHITECTURE v3
   (Center / Lateral / MasterMix / FXBus)
   =============================== */

if(window.BodyBeat && !BodyBeat.audioV3Initialized){

    BodyBeat.audioV3Initialized = true;

    const getCtx = BodyBeat.core.getAudioContext;

    const waitForAudio = setInterval(()=>{

        const ctx = getCtx();
        if(!ctx) return;

        clearInterval(waitForAudio);

        // Create buses
        BodyBeat.centerBus = ctx.createGain();
        BodyBeat.lateralBus = ctx.createGain();
        BodyBeat.masterMix = ctx.createGain();
        BodyBeat.fxBus = ctx.createGain();

        // Routing
        BodyBeat.centerBus.connect(BodyBeat.masterMix);
        BodyBeat.lateralBus.connect(BodyBeat.masterMix);

        BodyBeat.masterMix.connect(BodyBeat.fxBus);
        BodyBeat.fxBus.connect(ctx.destination);

        // Expose in API
        BodyBeat.core.getCenterBus = () => BodyBeat.centerBus;
        BodyBeat.core.getLateralBus = () => BodyBeat.lateralBus;
        BodyBeat.core.getMasterMix = () => BodyBeat.masterMix;
        BodyBeat.core.getFxBus = () => BodyBeat.fxBus;

        console.log("Audio Architecture v3 initialized");

    }, 300);

}


/* ===============================
   BODYBEAT AUDIO ARCHITECTURE v3.1
   (Master Migration Fix)
   =============================== */

/*
 NOTE:
 Full separation of center/lateral requires
 refactoring internal source routing.
 Until that refactor is done, we unify routing
 through original masterGain to ensure
 analyzer and FX receive signal correctly.
*/

if(window.BodyBeat && !BodyBeat.audioV31Fix){

    BodyBeat.audioV31Fix = true;

    const ctx = BodyBeat.core.getAudioContext();
    const master = BodyBeat.core.getMasterGain();

    if(ctx && master){

        // Ensure FX Bus exists
        if(!BodyBeat.fxBus){
            BodyBeat.fxBus = ctx.createGain();
            master.disconnect();
            master.connect(BodyBeat.fxBus);
            BodyBeat.fxBus.connect(ctx.destination);
        }

        // Alias buses to master until full refactor
        BodyBeat.core.getCenterBus = () => master;
        BodyBeat.core.getLateralBus = () => master;
        BodyBeat.core.getMasterMix = () => master;
        BodyBeat.core.getFxBus = () => BodyBeat.fxBus;

        console.log("Audio Architecture v3.1 unified routing active");
    }
}

</script>


<div id="audioManagerPanel" class="subPanel">
<div class="closeBtn" onclick="closePanel('audioManagerPanel')">✕</div>
<h3>Carga y gestión de archivos de audio</h3>

<div class="assignGrid" id="audioManagerGrid"></div>

<hr>

<h4>Carga Masiva</h4>
<button onclick="openMassLoader('center')">Carga Centro</button>
<button onclick="openMassLoader('left')">Carga Lateral Izquierdo</button>
<button onclick="openMassLoader('right')">Carga Lateral Derecho</button>

<br><br>
<button onclick="saveAudioManager()">Guardar Cambios</button>
<button onclick="clearAudioGrid()">Limpiar Grilla</button>
<button onclick="closePanel('audioManagerPanel')">Cerrar</button>

<input type="file" id="audioFileInput" accept="audio/*" hidden>
</div>


<div id="modulePanel" class="subPanel">
<div class="closeBtn" onclick="closePanel('modulePanel')">✕</div>
<h3>Conector Modular</h3>

<hr>
<h4>🎧 Módulos de Audio</h4>
<label><input type="checkbox"> Sidechain</label><br>

<hr>
<h4>🎛 Módulos de Efectos</h4>
<label><input type="checkbox"> Reverb</label><br>
<label><input type="checkbox"> Delay BPM</label><br>
<label><input type="checkbox"> Filtro Global</label><br>

<hr>
<h4>🌈 Módulos Visuales</h4>
<label><input type="checkbox"> Glow externo</label><br>
<label><input type="checkbox"> Neón real</label><br>
<label><input type="checkbox"> Partículas</label><br>
<label><input type="checkbox"> Modo Estrobo</label><br><br>

<button onclick="closePanel('modulePanel')">Guardar Cambios</button>
</div>


<div id="moduleManagerPanel" class="subPanel">
<div class="closeBtn" onclick="closePanel('moduleManagerPanel')">✕</div>
<h3>Module Manager</h3>

<div id="moduleList"></div>

<hr>
<h4>Agregar módulo externo</h4>
<input type="file" id="moduleFileInput" accept=".js"><br><br>

<button onclick="saveModuleState()">Guardar Configuración</button>
<br><br>
<button onclick="openDeleteModulesPanel()">Eliminar Módulos</button>

</div>


<div id="deleteModulesPanel" class="subPanel" style="display:none;">
<div class="closeBtn" onclick="closePanel('deleteModulesPanel')">✕</div>
<h3>Eliminar Módulos</h3>
<div id="deleteModulesList"></div>
<br>
<button onclick="confirmDeleteModules()">Guardar Cambios</button>
</div>


<button id="gridToggleBtn" style="
position:fixed;
bottom:90px;
left:50%;
transform:translateX(-50%);
background:#102a55;
border:2px solid #00ffff;
padding:10px 20px;
border-radius:25px;
color:white;
cursor:pointer;
z-index:250;
box-shadow:0 0 10px #00ffff;
">Mostrar / Ocultar Grilla</button>

<script>
document.getElementById("gridToggleBtn").onclick = toggleGridVisibility;
</script>

</body>
</html>
